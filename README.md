<img src="https://capsule-render.vercel.app/api?type=waving&color=auto&height=200&section=header&text=ITTY&fontSize=80&fontColor=ffffff" />
<p align="center"></p>

###  팀명 :
[![Typing SVG](https://readme-typing-svg.demolab.com?font=Jersey+10+Charted&size=46&pause=1000&color=003EFF&random=false&width=435&lines=1oT)](https://git.io/typing-svg)
- "1oT"라는 팀 이름은 "Internet of Things"의 약어인 "IoT"를 변형한 것으로, 여기서 "I"를 숫자 "1"로 대체하였습니다. 이 이름은 첫 번째라는 의미의 숫자 "1"을 사용함으로써 팀이 IoT 분야에서 빠르고 앞서서 발전하고자 하는 포부를 나타냈습니다. 1oT 팀은 IoT 기술과 하나 되어 꾸준히 발전해나가겠습니다.

<div align="center">
<figure class="half">
<img src="https://github.com/mini-xi/ittyreadme/blob/84a151c2c6045c0c95a7876118bc82d34bf03b18/img/ittylogo.jpg" height=175>
<img src="https://github.com/mini-xi/ittyreadme/blob/84a151c2c6045c0c95a7876118bc82d34bf03b18/img/1ot.png" height=175>
</figure>
</div>

###  팀원 :
 
[<img src="https://img.shields.io/badge/Github-Link-FFE482?logo=Github">](https://github.com/mini-xi) <strong>&nbsp;&nbsp;배성민</strong> <br>
[<img src="https://img.shields.io/badge/Github-Link-FF0000?logo=Github">](https://github.com/helloItsUniverse) <strong>&nbsp;&nbsp;소우주</strong> <br>
[<img src="https://img.shields.io/badge/Github-Link-EB99FF?logo=Github">](https://github.com/bucky1005) <strong>&nbsp;&nbsp;손세림</strong> <br>
[<img src="https://img.shields.io/badge/Github-Link-2C633B?logo=Github">](https://github.com/DYShin1) <strong>&nbsp;&nbsp;신대영</strong> <br>
[<img src="https://img.shields.io/badge/Github-Link-3D3A61?logo=Github">](https://github.com/jhlee6515) <strong>&nbsp;&nbsp;이준형</strong> <br>

## 1. 프로젝트 소개

> &nbsp;ITTY는 "Integration of Technology To You"의 약자로, 사용자에게 최신 IT 정보와 기술을 제공하는 웹 서비스입니다.<br>&nbsp; 이 서비스는 논문 검색, 스터디 또는 프로젝트 참여, 경력 개발자와의 커뮤니케이션, 공모전 정보 제공 등 다양한 기능을 통합하여 ITTY 하나로 여러 요구를 충족시키는 것을 목표로 합니다.<br> &nbsp;웹사이트는 Vue, HTML, JavaScript를 이용한 프론트엔드와 Java를 사용한 백엔드로 구성되어 있으며, Intellij로 개발되었습니다.&nbsp;서버는 Docker와 Kubernetes를 통해 관리됩니다.&nbsp; 현재는 크롤링을 통해 최신 IT 정보를 수집해 제공하고 있으며, 향후 WebSocket을 이용한 실시간 채팅 및 쪽지 기능과 ElasticSearch를 활용한 검색 기능을 도입할 계획입니다.

## ⚙️ 기술스택
<div align="center">

|SpringBoot|SpringSecurity|Vue|HTML|CSS|JavaScript|MariaDB|Spring Data JPA|Bootstrap|
|---|---|---|---|---|---|---|---|---|
|<img src="https://img.shields.io/badge/Spring Boot-6DB33F?style=for-the-badge&logo=Spring Boot&logoColor=white">|<img src="https://img.shields.io/badge/Spring Security-6DB33F?style=for-the-badge&logo=Spring Security&logoColor=white">|<img src="https://img.shields.io/badge/Vue-4FC08D?style=for-the-badge&logo=Vue.js&logoColor=white">|<img src="https://img.shields.io/badge/HTML-E34F26?style=for-the-badge&logo=HTML5&logoColor=white">|<img src="https://img.shields.io/badge/CSS-1572B6?style=for-the-badge&logo=CSS3&logoColor=white">|<img src="https://img.shields.io/badge/JavaScript-F7DE1E?style=for-the-badge&logo=JavaScript&logoColor=white">|<img src="https://img.shields.io/badge/MariaDB-003545?style=for-the-badge&logo=MariaDB&logoColor=white">|<img src="https://img.shields.io/badge/Spring Data JPA-6DB33F?style=for-the-badge">|<img src="https://img.shields.io/badge/Bootstrap-7952B3?style=for-the-badge&logo=Bootstrap&logoColor=white">|

|Jenkins|Kubernetis|Docker|Redis|Grafana|Prometheus|ngrok|Json Web Tokens|
|---|---|---|---|---|---|---|---|
|<img src="https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=Jenkins&logoColor=white">|<img src="https://img.shields.io/badge/Kubernetes-326CE5?style=for-the-badge&logo=Kubernetes&logoColor=white">|<img src="https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=Docker&logoColor=white">|<img src="https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=Redis&logoColor=white">|<img src="https://img.shields.io/badge/Grafana-F46800?style=for-the-badge&logo=Grafana&logoColor=white">|<img src="https://img.shields.io/badge/Prometheus-E6522C?style=for-the-badge&logo=Prometheus&logoColor=white">|<img src="https://img.shields.io/badge/ngrok-1F1E37?style=for-the-badge&logo=ngrok&logoColor=white">|<img src="https://img.shields.io/badge/JSON Web Tokens-000000?style=for-the-badge&logo=JSON Web Tokens&logoColor=white">|
</div>

## ⚙️ 개발도구
<div align="center">

|IntelliJ IDEA|Visual Studio|HeidiSQL|Figma|GitHub|Slcak|Jira|
|---|---|---|---|---|---|---|
|<img src="https://img.shields.io/badge/IntelliJ IDEA-000000?style=for-the-badge&logo=IntelliJ IDEA&logoColor=white">|<img src="https://img.shields.io/badge/Visual Studio-007ACC?style=for-the-badge&logo=Visual Studio Code&logoColor=white">|<img src="https://img.shields.io/badge/HeidiSQL-6DB33F?style=for-the-badge">|<img src="https://img.shields.io/badge/Figma-F24E1E?style=for-the-badge&logo=Figma&logoColor=white">|<img src="https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=GitHub&logoColor=white">|<img src="https://img.shields.io/badge/Slack-4A154B?style=for-the-badge&logo=Slack&logoColor=white">|<img src="https://img.shields.io/badge/Jira-0052CC?style=for-the-badge&logo=Jira&logoColor=white">|

</div>

<br>

<details>
<summary><b>개발도구 및 기술스택 Version</b></summary>
 
- Java17
- Spring 3.2.4
- Gradle 8.5+
- Spring Security 6
- Jwt 0.11.5
- CSS 3
- HTML 5
- Bootstrap 5
- Kubernetis 1.29.1
- Docker 25.0.3
- Jasypt 3.0.5
- J soup 1.17.2
</details>

<hr>

## 📋 Architecture
<img src="https://github.com/mini-xi/ittyreadme/blob/e3dbf698fe21f05ddf398fb960f433c407b7ea0b/img/itty_architecture.png"/>
<br>

### Jasypt
  
*: Java Simplified Encryption, 자바 애플리케이션에서 개발자가 데이터를 안전하게 암호화하고 복호화할 수 있도록 도와주는 라이브러리. 이를 사용함으로써 데이터베이스 내의 중요 정보, 환경 설정 파일의 민감한 데이터, 소스 코드 내에 포함된 비밀번호 같은 것들을 보호( ex) .yml )*


## ⚙️ Build Tutorial

### 1. Backend
<b> BackEnd Server를 Docker 컨테이너로 생성</b>
<b> 1.1. build.gradle 에 Jasypt 의존성 추가</b><br>

<aside>
🚨 jasypt 3.0.5 보다 이전 버전에서는 빌드 커맨드가 잘 작동하지 않아 현재 최신 버전인 3.0.5 버전을 사용하였다.
</aside>

```powershell
implementation 'com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.5'

tasks.named('test') {
	useJUnitPlatform()
	systemProperty 'jasypt.encryptor.password', findProperty("jasypt.encryptor.password")
}
```

<b> 1.2. Dockerfile에 jasypt 관련 내용 추가 </b><br>

```docker
FROM openjdk:17-alpine
COPY build/libs/*.jar app.jar

ENTRYPOINT ["java", "-jar", "app.jar", "--jasypt.encryptor.password=itty"]
```

<b> 1.3. build 파일 생성 </b><br>
<aside>
🚨 설정파일인 application.yml의 민감정보들을 암호화하여 Github에 업로드하기 위해
Jasypt를 사용하였다.

이로 인해 암호화된 민감정보들을 다시 복호화하여 프로그램이 인식하도록 프로그램 외부에서 복호화 key를 전달해주어야 하는데,

그 key를 전달하는 방법으로 CLI 환경에서 빌드하는 명령에 key 값을 추가하는 방식을 택하였다.

gradle을 사용하여 빌드 시 `-P` 플래그를 추가한다.

</aside>

```powershell
./gradlew clean build -P jasypt.encryptor.password=itty
```

- `clean`: 기존에 만들어진 build를 지운 후, 새 build 파일을 생성

<b> 1.4. Docker Hub 로그인</b><br>

```java
docker login
```

<b> 1.5. Docker에 Dockerfile (image) 생성하기</b><br>

```java
docker build -t (DockerHubId)/backend_server .
```

- Docker에 (DockerHubId)/backend_server 라는 이름의 Dockerfile(image)를 생성
- 이때 [DockerHubId]은 본인의 DockerHub 아이디로 작성
- 마지막에 .을 붙이는 이유: 현재 디렉토리에 존재하는 Dockerfile을 기준으로 image 파일을 생성한다는 의미

<b> 1.6. Docker에 image Push(이미지 배포) </b><br>

```java
docker push eodud3196/backend_server
```

- 생성한 이미지 파일을 도커에 푸시

<b> 1.7. manifest 파일 생성</b><br>

- deployment 파일 생성
    
    [itty-project-deployment.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/itty-project-deployment.yml)


- service 파일 생성
    
    [itty-project-service.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/itty-project-service.yml)
  

<b> 1.8. kubelet에 deployment 적용하여 Pod 생성(컨테이너 배포)</b><br>

```powershell
kubectl apply -f itty-project-deployment.yml
```

<b> 1.9. Proxy에 service 적용</b><br>

```powershell
kubectl apply -f itty-project-service.yml
```

### 2. Frontend

```visual-basic
npm install
```

- 필요한 모든 종속성을 설치하고, 프로젝트가 생산 환경에서 제대로 실행될 수 있도록 구성
- 개발 환경에서는 디버깅을 위한 도구가 필요하지만, 배포 시에는 최적화된 코드가 필요함. `npm install`은 필요한 모든 환경 설정 파일과 스크립트를 설치하며, 이는 배포 과정에서 코드를 최적화하고, 필요한 모든 구성 요소가 포함되도록 함
- 여러 플러그인과 확장 기능을 사용

```visual-basic
npm install axios
```

- HTTP 요청을 보낼 수 있는 간단하고 직관적인 API를 제공
- 비동기 코드를 보다 쉽게 작성하고 관리
- 모든 주요 브라우저에서 동작하며, 오래된 브라우저를 지원하기 위한 자동 변환 기능을 제공
- JSON 데이터를 자동으로 파싱하여 개발자가 서버로부터 받은 응답을 즉시 객체로 사용할 수 있게 함

```visual-basic
npm run dev
```

- 배포 받은 Vue 파일 실행 (Localhost:(포트번호) 로 지정)

## ⚙️ Continueous Deployment

### Pod / Cluster

<details>
	<summary><b>Pod 및 Cluster 구현 및 방법</b></summary>
	<br>
Pod: 쿠버네티스에서 가장 작은 배포 단위, 하나 이상의 컨테이너로 구성될 수 있음. 각 Pod는 공유된 네트워크와 스토리지 리소스를 가지고, 이를 통해 포함된 컨테이너들이 서로 통신할 수 있음. 각 Pod는 독립적인 실행 환경을 제공하며, 일반적으로 하나의 서비스나 어플리케이션 컴포넌트를 실행하는데 사용됨.

Cluster: 여러 노드(물리적 또는 가상의 서버)로 구성된 쿠버네티스의 구성 요소. 클러스터는 하나 이상의 마스터 노드와 여러 워커 노드를 포함할 수 있음. 마스터 노드는 클러스터의 관리와 스케줄링을 담당하며, 워커 노드는 실제로 컨테이너화된 애플리케이션을 실행. 클러스터는 고가용성, 확장성 및 재해 복구를 가능하게 함.

<b>Pod 및 Cluster</b>

1. Kubernetes 설치: 클러스터 구현을 시작하기 전에 쿠버네티스를 설치.

2. 클러스터 설정: 다른 도구를 사용하여 클러스터를 초기화하고 설정해야함. 마스터 노드와 워커 노드를 준비하고, 적절한 네트워크 플러그인을 설치.

3. Pod 생성: YAML 또는 JSON 형식의 매니페스트 파일을 작성합니다. 이 파일은 Pod의 구조, 실행할 컨테이너, 리소스 할당 등을 정의함.

4. 클러스터 관리: 클러스터와 리소스의 상태를 모니터링하고, 필요에 따라 확장하거나 업데이트. kubectl과 같은 CLI 도구를 사용하여 클러스터를 관리.

5. 애플리케이션 배포: 애플리케이션을 클러스터에 배포하고, 서비스와 로드 밸런싱을 설정하여 외부에서 접근 가능하게 함.
</details>

### 3. Redis

<aside>
💡 Spring Security 로그인 토큰 관리를 위한 Redis 서버 Kubernetes 실행 과정

</aside>

<b> 3.1. manifest 파일 생성</b><br>

- redis 디렉토리 생성
- Kubernetes 실행을 위한 yml 파일 작성
    
    [redis-configmap.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/redis-configmap.yml)
    
    - 애플리케이션 설정을 저장하는 데 사용되는 리소스
    
    [redis-pod.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/redis-pod.yml)
    
    [redis-svc.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/redis-svc.yml)
    
    ```yaml
      externalIPs:
      - 192.168.0.31
    ```
    
    - service 파일에 다음과 같이 IP를 설정함
    - Backend Server에서 192.168.0.31:6379를 이용하여 서로 통신 가능 하게 적용

<b> 3.2. Kubernetes Redis 실행</b><br>

```bash
kubectl apply -f redis/
```

- redis 디렉토리 밖에서 위와 같은 명령어를 실행 하면 3개의 .yml 파일이 실행 됨

---

### 4. MariaDB

<b> 4.1 Backend 서버와 통신을 위한 MariaDB Docker 이미지 생성</b><br>

<b> 4.1.1 Dockerfile 생성</b><br>

Jenkins :<br>
[Dockerfile](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/Dockerfile)

DB :<br>
[Dockerfile2](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/Dockerfile%202)

- 해당 파일은 MariaDB 컨테이너 이미지를 사용하여 데이터베이스를 초기화하는 작업을 수행함.
- 초기화 작업은 빌더 스테이지에서 수행되며, 그 결과로 초기화된 데이터베이스 디렉토리가 생성됨
- 다음 초기화된 데이터베이스 디렉토리를 기본 MariaDB 이미지로 복사하여 최종 이미지를 생성

[setup.sql](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/setup.sql)

- 해당 파일은 itty Database DDL문으로 Docker 이미지 초기 세팅할 DB이다.

<b> 4.1.2 Docker에 Dockerfile (image) 생성하기 </b><br>

```bash
docker build -t {DB image name}
```

<b> 4.1.3 Docker에 image Push(이미지 배포) </b><br>

```bash
docker push {DB image name}
```

<b> 4.2.1 manifest 파일 생성 </b><br>

- db 디렉토리 생성
- Kubernetes 실행을 위한 yml 파일 작성
    
    [itty-db-volume.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/itty-db-volume.yml)
    
    - 애플리케이션 설정을 저장하는 데 사용되는 리소스
    
    [itty-db-deployment.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/itty-db-deployment.yml)
    
    [itty-db-service.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/itty-db-service.yml)
    
    ```yaml
      externalIPs:
      - 192.168.0.30
    ```
    
    - service 파일에 다음과 같이 IP를 설정함
    - Backend Server에서 192.168.0.30:3306을 이용하여 서로 통신 가능 하게 적용

<b> 4.2.2 Kubernetes MariaDB실행 </b><br>

```bash
kubectl apply -f db/
```

- redis 디렉토리 밖에서 위와 같은 명령어를 실행 하면 3개의 .yml 파일이 실행 됨

---

### 5. Prometheus

<aside>
💡 Prometheus는 시스템 모니터링 및 경고 툴킷이며, 이를 사용하여 매트릭 수집 및 대시보드 구축이 가능하다. 실시간으로 시스템의 상태를 모니터링하고, 다양한 지표를 수집하여 시스템의 안정성과 성능을 보장 하기 위함이다.

</aside>

<b> 5.1. manifest 파일 생성</b><br>

- Prometheus 디렉토리 생성
- Kubernetes 실행을 위한 yml 파일 작성
    
    [prometheus-configmap.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/prometheus-configmap.yml)
    
    - 현재 이 시스템에서는 Backend와 Jenkins Server 모니터링을 진행함.
    
    ```yaml
        scrape_configs:
          - job_name: prometheus
            metrics_path: '/actuator/prometheus'
            static_configs:
              - targets: ['10.1.1.67:8888']       
    
          - job_name: jenkins
            metrics_path: '/prometheus/'
            static_configs:
              - targets: ['083f-183-109-114-170.ngrok-free.app']
            scheme: https
    ```
    
    - Backend 서버를 k8s로 실행시킨 후 kubectl describe {backend pods 이름}을 통해 IP를 확인함.
    - 해당 IP를 prometheus.static_configs.targes 쪽에 port 8888로 수정함.
    - jenkins 서버 모니터링을 위해 imac위에서 동작하고 있는 jenkins를 ngrok을 통해 주소를 Backend서버 targets 수정한것 처럼 수정한다.
    
    [prometheus-service.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/prometheus-service.yml)
    
    [prometheus-deployment.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/prometheus-deployment.yml)
    
    - service 파일에 다음과 같이 IP를 설정함
    - Backend Server에서 192.168.0.31:6379를 이용하여 서로 통신 가능 하게 적용

<b> 5.2. Kubernetes Prometheus 실행</b><br>

```bash
kubectl apply -f prometheus/
```

- redis 디렉토리 밖에서 위와 같은 명령어를 실행 하면 3개의 .yml 파일이 실행 됨

<b> 5.3. 실행 확인</b><br>

- 브라우저 환경에서 localhost:30090을 실행함.
- targets에 들어가 jenkins, backend가 configmap에서 설정한 주소로 접근이 가능한지 확인함

---

### 6. Grafana

<aside>
💡 시계열 매트릭 데이터를 시각화 하는데 가장 최적화된 대시보드를 제공해주는 오픈소스 툴킷. Prometheus에서 전달한 데이터를 대시보드에 시각적으로 표현함으로써, 관리자는 실시간으로 서비스의 상태를 확인하고 이상 현상을 즉시 파악 가능 함.

</aside>

<b> 6.1. manifest 파일 생성</b><br>

- grafana 디렉토리 생성
- Kubernetes 실행을 위한 yml 파일 작성
    
    [grafana-volume.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/grafana-volume.yml)
    
    - 애플리케이션 설정을 저장하는 데 사용되는 리소스
    
    [grafana-deployment.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/grafana-deployment.yml)
    
    [grafana-service.yml](https://github.com/mini-xi/ittyreadme/blob/d8ae941750f53d7537c904012273f5476bf30c9c/yml/grafana-service.yml)
    

<b> 6.2. Kubernetes Redis 실행</b><br>

```bash
kubectl apply -f grafana/
```

- redis 디렉토리 밖에서 위와 같은 명령어를 실행 하면 3개의 .yml 파일이 실행 됨

<b> 6.3. Dashboards 생성</b><br>

- localhost:30000으로 접속함.
- Prometheus에서 데이터를 전송받기 위해 data source → prometheus 클릭
- kubectl describe {prometheus pod 이름}을 통해 알아낸 ip주소를 작성한다.
    - http://{pod 주소}:9090
- Dashboards 새성 imports를 통해 모니터링 대시보드를 생성 가능 함.
    - 19004 → Spring Boot 3.x Statistics
    - 12646 → Jenkins
 
<br>

---

### 7. Jenkins

<aside>
💡 Jenkins는 지속적인 통합(Continuous Integration, CI) 및 지속적인 전달(Continuous Delivery, CD)를 가능하게 하는 오픈 소스 자동화 도구. 소프트웨어 개발 및 배포 프로세스를 자동화하여 개발자 및 팀이 효율적으로 작업할 수 있는 환경을 구축하기 위해 적용함.

</aside>

<b>7.1 Dockerfile 생성</b>

[Dockerfile](https://github.com/mini-xi/ittyreadme/blob/d94bf1cdb581931e32a2f5d0a3b592e87f611696/yml/Dockerfile)

- 해당 파일은 Jenkins 컨테이너 이미지를 사용하여 초기화하는 작업을 수행함.
- Mac용이며 생성된 컨테이너안 리눅스에 Docker가 설치가 안되어있음.
- 추가적으로 컨테이너 실행 후 아래와 같은 명령어를 실행해야 함.

```bash
docker exec -itu 0 {컨테이너 이름} bash        #컨테이너 안 리눅스 접근
	
curl -fsSL https://get.docker.com -o get-docker.sh    # docker 설치
sh get-docker.sh
```

[docker-compose.yml](https://github.com/mini-xi/ittyreadme/blob/d94bf1cdb581931e32a2f5d0a3b592e87f611696/yml/docker-compose.yml)

```bash
docker-compose up
```

- 위와 같은 명령어로 jenkins 실행

<b>7.2 플러그인 설치</b>

- 도커 컨테이너 실행이 완료 되면 추가 플러그인 설치가 필요함.
    - Dashboard → Jenkins 관리 → Plugin
- Locale, Publish over ssh, Pipeline: stage view, prometheus 설치
    - Dashboard → Jenkins 관리 → System
    - Locale → Default Language를 ko로 변경

<b>7.3 ssh 설정</b>

- Jenkins 도커 컨테이너 접속

```bash
docker exec -itu 0 {컨테이너 이름} bash        #컨테이너 안 리눅스 접근
```

- ssh-keygen 생성

```bash
# my-jenkins 디렉토리 생성
mkdir ./ssh-jenkins

# my-jenkins 디렉토리로 이동
cd ./ssh-jenkins

# .ssh 디렉토리 생성
mkdir ./.ssh

# ls -al(숨어 있어 -al 옵션으로 확인.)
ssh-keygen -t rsa -f .ssh/ssh-jenkins-github--key

# 비밀번호는 10자 이상 추천

# .ssh 디렉토리로 이동
cd ./.ssh

**# private key
cat ssh-jenkins-github--key

# public key
cat ssh-jenkins-github--key.pub**
```

<b>7.3.1 Jenkins ssh public key 등록</b>

- Dashboard → Jenkins 관리 → Security

```bash
security:
  gitHostKeyVerificationConfiguration:
    sshHostKeyVerificationStrategy:
      manuallyProvidedKeyVerificationStrategy:
        approvedHostKeys: |-
          github.com {**cat ssh-jenkins-github--key.pub 통해 확인한 public key 붙여넣기**}
```

- Credentials 추가(ssh private key를 my-github-key로 등록)
    - ID는 ssh key 설정할때 작성한 이름으로 작성한다. ex) ssh-jenkins-github--key
    - private key 붙여넣기

<b>7.4 Webhooks 설정</b>

- public key를 개발중인 Backend github repository쪽 settings → Deploy keys에 붙여넣어 키 설정.
- ngrok을 이용하여 jenkins → {ngrok주소}:8080을 하면 jenkins를 접속할 수 있게 설정함.
    - {ngrok주소}/github-webhook/을 settings → Webhooks에 추가함.

<b>7.5 Jenkins CI/CD 사용</b>

<b>7.5.1. Jenkins Tools 설정</b>

- java 설정
    - add JDK 클릭 후 Name → openJDK17, JAVA_HOME → /opt/java/openjdk 설정
- Gradle
    - name → gradle, install automatically 체크

<b>7.6 Jenkins pipeline 구축</b>

- 빌드 → Docker image 생성 → Docker hub에 push
    - Docker hub관련 Credential 구축
        - Username → Docker hub 사용자 이름
        - Password → Docker hub 비밀번호
        - ID → DOCKERHUB_PASSWORD
- Pipeline 작성
    - GitHub hook trigger for GITScm polling 체크
    - Script 작성 - 보안을 위하여 ./gradlew clean build -P jasypt.encryptor.password=itty로 변경

```bash
pipeline {
    agent any

    tools {
        gradle 'gradle'
        jdk 'openJDK17'
    }

    environment {
        DOCKERHUB_USERNAME = '{도커허브 아이디}'
        GITHUB_URL = '{백엔드 깃허브 주소}'
    }

    stages {
        stage('Preparation') {
            steps {
                script {
                    sh 'docker --version' // Docker가 설치되어 있는지 확인
                }
            }
        }
        stage('Source Build') {
            steps {
                // 소스파일 체크아웃
                git branch: 'main', url: '{백엔드 깃허브 주소}'

                // 소스 빌드
                // 755권한 필요 (윈도우에서 Git으로 소스 업로드시 권한은 644)
                sh "chmod +x ./gradlew"
                sh "./gradlew clean build -P jasypt.encryptor.password=itty"
            }
        }
        stage('Container Build') {
            steps {	
    
                // jar 파일 복사
                sh "cp ./build/libs/*.jar ."
    
                // 컨테이너 빌드 및 업로드
                sh "docker build -t ${DOCKERHUB_USERNAME}/{Docker image 이름}:latest ."

                // docker hub로 push
                withCredentials([usernamePassword(credentialsId: 'DOCKERHUB_PASSWORD', usernameVariable: 'DOCKERHUB_USER', passwordVariable: 'DOCKERHUB_PASS')]) {
                    sh "echo $DOCKERHUB_PASS | docker login --username $DOCKERHUB_USER --password-stdin"
                    sh "docker push ${DOCKERHUB_USERNAME}/test-pipe:latest"
                }
            }
        }
    }
}
```
- gradle 'gradle': Gradle 빌드 도구를 사용하도록 설정.
- (jdk 'openJDK17': OpenJDK 17을 사용하도록 지정)

<b>Stage(Preparation)</b>
- 필요한 도구들이 설치되어 있는지 확인
- docker --version: Docker가 설치되어 있는지 확인하는 커맨드를 실행.

<b>Stage(Source Build)</b>
- 소스 코드를 체크아웃하고 빌드.
- git branch: 'main', url: '${GITHUB_URL}': 지정된 GitHub URL에서 메인 브랜치의 최신 소스 코드를 체크아웃.
- chmod +x ./gradlew: Gradle wrapper 파일에 실행 권한을 부여.
- ./gradlew clean build -P jasypt.encryptor.password=itty: 소스 코드를 빌드.(-P jasypt.encryptor.password=itty로 빌드 중 필요한 암호화 키를 제공)

### Build가 제대로 되지 않았을 때

<details>
	<summary><b>Build or Distribution Error </b></summary>
	<br>
	확인해 볼 내용:<br>
1. 로그 확인<br>
- 빌드 로그: 빌드 프로세스 중 발생한 에러와 경고를 확인. Jenkins를 통해 확인.<br>
- 시스템 로그: 서버의 시스템 로그를 검토하여 빌드 또는 배포 도중 시스템에 발생한 문제를 확인.<br><br>
2. 설정 검토<br>
- 빌드 및 배포 스크립트: 자동화된 스크립트에서 오류가 없는지 검토. 종종 경로 설정이 잘못되거나 필요한 변수가 설정되지 않는 등의 문제가 있을 수 있음<br>
- 환경 설정: 개발, 테스트, 프로덕션 등의 환경에 따라 다른 설정을 사용하는 경우, 올바른 환경 변수와 설정이 적용되었는지 확인합니다.<br><br>
3. 의존성 관리<br>
- 라이브러리 및 도구: 사용 중인 라이브러리와 도구의 버전이 프로젝트 요구사항과 일치하는지 확인. 위쪽의 개발 도구에서 사용된 버전을 확인할 수 있음.<br>
- 네트워크 문제: 외부 라이브러리나 도구를 다운로드할 때 네트워크 문제로 실패할 수 있으므로, 네트워크 접근성을 확인.<br><br>
4. 리소스 확인<br>
- 디스크 공간: 충분한 디스크 공간이 있는지 확인. 이미지 파일을 받아오는 과정이나 사용 중에 충분한 디스크 공간이 없을 시 에러가 발생할 수 있음<br>
- 메모리 및 CPU 사용률: 빌드 또는 배포 중에 메모리 또는 CPU 사용률에 대한 모니터링.<br><br>
5. 롤백 및 재시도<br>
- 롤백: 이전 버전으로 롤백하여 시스템이 정상적으로 작동하는지 확인.<br>
- 재시도: 일시적인 문제로 인해 실패했을 수 있으므로, 문제를 수정한 후 빌드 또는 배포를 재시도.<br><br>
</details>

### Jenkins를 통한 Pipeline 구축, CI/CD

<details>
	<summary><b>Jenkins Schedule 및 구현</b></summary>

1. Jenkins 설치: Jenkins를 서버에 설치. 이를 통해 공식 웹사이트에서 다운로드 가능한 패키지나 컨테이너 이미지를 사용<br>
- 필수 플러그인 설치: Git, Maven, Docker, Slack Notification...<br>
 
2. 소스 코드 관리<br>
- 저장소 연결: GitHub, Bitbucket 등의 소스 코드 저장소와 Jenkins를 연결. 웹훅(webhook)을 설정하여 소스 코드에 변경이 발생할 때마다 Jenkins가 자동으로 빌드를 트리거.<br>

3. 빌드 트리거<br>
- 스케줄 설정: Jenkins의 빌드 트리거 기능을 사용하여, 정기적으로 빌드가 실행되도록 스케줄을 설정.<br>
- 푸시 트리거: 소스 코드가 변경될 때마다 자동으로 빌드가 시작되도록 설정.<br>

4. 빌드 파이프라인 구성<br>
- 파이프라인 스크립트 작성: Jenkinsfile을 작성하여 빌드, 테스트, 배포의 각 단계를 코드로 정의. Declarative Pipeline 또는 Scripted Pipeline 방식을 사용. ITTY 서비스는 "Declarative Pipeline"을 사용(Declarative Pipeline: 구조화된 문법을 사용, 각 파이프라인은 stages와 steps로 구성)<br>
- 다단계 빌드 파이프라인: 빌드, 테스트, 배포를 단계별로 나누어 각 단계에서의 성공 여부에 따라 다음 단계를 실행하거나 중단.<br>

5. 배포 자동화<br>
- 컨테이너화 및 배포: Docker, Kubernetes 등을 사용하여 애플리케이션을 컨테이너화하고, 자동으로 프로덕션 환경에 배포.<br>

6. 모니터링 및 알림<br>
- 모니터링 도구 통합: Prometheus, Grafana 등을 사용하여 애플리케이션의 성능을 실시간으로 모니터링.<br>
- 알림 설정: Slack, 이메일 등을 통해 이슈에 대해서 알림을 받아볼 수 있음.<br>

</details>

## 2. WBS
<details>
  <summary><b>ITTY WBS</b></summary>
   <a href="https://docs.google.com/spreadsheets/d/1swhqPyeuwVAs0JhWyNGbQsM2AFr49tghBM3hoZGmj_8/edit#gid=0"><img src="https://github.com/mini-xi/ittyreadme/blob/fe0a3899f7b26fb38ef01cf017289d7cb99aed95/img/ITTY-WBS.jpg"/></a>
</details>

## 3. 요구사항 명세서
<details>
 <summary><b>ITTY 요구사항 명세서</b></summary>
<a href="https://docs.google.com/spreadsheets/d/1wuUfWmf4uBKcitZtEazmBs3p3qLT8VQIUCQV8zQFbRM/edit#gid=0"><img src="https://github.com/mini-xi/ittyreadme/blob/cf0072894a96133116c7a2675d8c23b30b9029e6/img/ITTY-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD%EB%AA%85%EC%84%B8%EC%84%9C%20-%20%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD%EB%AA%85%EC%84%B8%EC%84%9C_page-0001.jpg"/></a>
</details>

## 4. DDD / Modeling

<details>
 <summary><b>ITTY DDD</b></summary>
 <div align="center">
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd1.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd2.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd3.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd4.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd5.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd6.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd7.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/3cd89d4572341658048a6db67d4c454e8e3ad438/img/itty_ddd8.png"/>
 </div>
</details>

<details>
 <summary><b>ITTY Modeling</b></summary>
 
 - 논리 모델링
 
 <div align="center">
   <img src="https://github.com/mini-xi/ittyreadme/blob/c9f23e4580f33b93936e89a2ce9c68715ab77a92/img/itty_%EB%85%BC%EB%A6%AC%EB%AA%A8%EB%8D%B8%EB%A7%81.png"/>
 </div>
<br>
 
 - 물리모델링

 <div align="center">
   <img src="https://github.com/mini-xi/ittyreadme/blob/c9f23e4580f33b93936e89a2ce9c68715ab77a92/img/itty_%EB%AC%BC%EB%A6%AC%EB%AA%A8%EB%8D%B8%EB%A7%81.png"/>
 </div>
 
 </details>

## 5. API 명세서
<details>
 <summary><b>ITTY API 명세서</b></summary>
<a href="https://docs.google.com/spreadsheets/d/1lr_gEIuy8DTv-7cAwzX8ZR8aSYRaOAROJXhfoZUX7EI/edit#gid=0"><img src="https://github.com/mini-xi/ittyreadme/blob/036a43a7b31676ed127a73b84e1f3aa6b0e0105d/img/itty-API%20%EB%AA%85%EC%84%B8%EC%84%9C%20-%20API%EB%AA%85%EC%84%B8%EC%84%9C_page-0001.jpg"></a>
</details>

## 6. WireFrame
<details>
 <summary><b>ITTY WireFrame</b></summary>
<img src="https://github.com/mini-xi/ittyreadme/blob/8f82491222083dc4f96c1e5c2f6a39053f038334/img/wireframe_itty.png"/>
</details>

## 7. Story Board

<details>
<summary><b>ITTY Story Board </b></summary>
<div align="center">
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_001.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_002.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_003.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_004.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_005.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_006.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_007.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_008.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_009.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_010.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_011.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_012.png"/>
    <img src="https://github.com/mini-xi/ittyreadme/blob/fc207d14c68663101fce37ba36d7c1696a36111a/img/story_013.png"/>
</div>
</details>


## 8. 테스트 정의서

<details>
 <summary><b>ITTY 테스트 명세서</b></summary>
<a href="https://docs.google.com/spreadsheets/d/1IS_woAh7IsvPFhevX0S7vHAVZlR19LKZNzXk-3528i4/edit#gid=0"><img src="https://github.com/mini-xi/ittyreadme/blob/7a5d39c75ffbcde7244a3a53808ca5f83f543d06/img/ITTY-%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%BC%80%EC%9D%B4%EC%8A%A4%20%EC%A0%95%EC%9D%98%EC%84%9C01.jpg"/></a>
<a href="https://docs.google.com/spreadsheets/d/1IS_woAh7IsvPFhevX0S7vHAVZlR19LKZNzXk-3528i4/edit#gid=0"><img src="https://github.com/mini-xi/ittyreadme/blob/7a5d39c75ffbcde7244a3a53808ca5f83f543d06/img/ITTY-%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%BC%80%EC%9D%B4%EC%8A%A4%20%EC%A0%95%EC%9D%98%EC%84%9C02.jpg"/></a>
</details>

## 9. 테스트

<details>
	<summary><b>Test</b></summary>
1. Sign Up
	<p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/d497ac1a0de5f3005c1f198ec3ef743c81736a03/img/test_itty_signup.gif"/>
	</p>
2. Login
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/d497ac1a0de5f3005c1f198ec3ef743c81736a03/img/test_itty_login.gif"/>
	</p>
3. Logout
         <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/d497ac1a0de5f3005c1f198ec3ef743c81736a03/img/test_itty_logout.gif"/>
	</p>
4. Sign Out
         <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/d497ac1a0de5f3005c1f198ec3ef743c81736a03/img/test_itty_signout.gif"/>
	</p>
5. Main Page
         <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_mainpage.gif"/>
	</p>
6. Main Page ( Guide-scroll )
         <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_mainguidescroll.gif"/>
	</p>
7. Main Page ( Service-scroll )
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/3414c001a22c0a4061e196f3714b1ca7c818a960/img/test_itty_mainpageservicescroll.gif"/>
	</p>
8. Main Page( Click event-To Trend Board)
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/3414c001a22c0a4061e196f3714b1ca7c818a960/img/test_itty_mainpagetoTrend.gif"/>
	</p>
9. Event Page
         <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_eventboard.gif"/>
	</p>
10. Trend Board
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_trendboard.gif"/>
	</p>
11. Article Board( Free Board )
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_article.gif"/>
	</p>
12. Article View
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_article_view.gif"/>
	</p>
13. Article Comment
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_freeboard_comment.gif"/>
	</p>
14. Article Comment Like
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/bc1f3158f8507769d386a5946aa2297f889a5ae6/img/test_itty_commentlike.gif"/>
	</p>
15. Mainpage to Profile
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/3414c001a22c0a4061e196f3714b1ca7c818a960/img/test_itty_mainpagetoProfile.gif"/>
	</p>
16. Profile Category
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/3414c001a22c0a4061e196f3714b1ca7c818a960/img/test_itty_profileCategory.gif"/>
	</p>
17. User Posted View
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/3414c001a22c0a4061e196f3714b1ca7c818a960/img/test_itty_userPost.gif"/>
	</p>
18. User Replied View
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/c362c794b2efe02ce9006cb58a208ab1416f5630/img/test_itty_userReply.gif"/>
	</p>
19. Modify User
            <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/3414c001a22c0a4061e196f3714b1ca7c818a960/img/test_itty_modifyUser.gif"/>
	</p>
20. Modify User Complete
        <p align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/3414c001a22c0a4061e196f3714b1ca7c818a960/img/test_itty_modifyUserComplete.gif"/>
	</p>

	
</details>


## ⚙️ Docker / Kubernetes

<div align="center">

<img src="https://github.com/mini-xi/ittyreadme/blob/9b3b3a0b3912d2f23e09dae8a3148caa70c61473/img/dockerkubernetis1.png" height=300/>
</div>

<br>

<b> Docker를 활용하여 ITTY 서비스의 백엔드와 데이터베이스를 컨테이너화함으로써, 각 서비스의 실행 환경을 격리하고 빠르게 배포할 수 있는 기반을 마련하였고, 이 컨테이너들은 Kubernetes라는 컨테이너 오케스트레이션 플랫폼에 의해 관리됨. Kubernetes는 복잡한 컨테이너화된 어플리케이션을 자동으로 배포, 확장 및 운영하는데 사용하여 Docker Container를 보다 효율적으로 관리.</b>

<br>

<div align="center">

|Docker|Kubernetes|
|:---:|:---:|
|<img src="https://github.com/mini-xi/ittyreadme/blob/9b3b3a0b3912d2f23e09dae8a3148caa70c61473/img/docker.png"/>|<img src="https://github.com/mini-xi/ittyreadme/blob/9b3b3a0b3912d2f23e09dae8a3148caa70c61473/img/kubernetes.png"/>|
|애플리케이션을 컨테이너라고 불리는 표준화된 단위로 포장하는 기술. 컨테이너는 애플리케이션과 그 애플리케이션이 필요로 하는 모든 종속성을 포함하여 어디에서나 동일하게 실행될 수 있도록 함|여러 대의 서버(노드)에 걸쳐 컨테이너화된 애플리케이션을 배포, 관리, 확장하는데 사용되는 오픈소스 오케스트레이션 플랫폼|

</div>

### Kubernetes Orchestration

<details>
 <summary><b>Kubernetes Orchestration</b></summary>
<br>
<b>Orchestration?</b> 여러 개의 컴퓨터 시스템, 애플리케이션 및/또는 서비스를 조율하고 관리하는 것으로, 여러 개의 작업을 함께 연결하여 크기가 큰 워크플로나 프로세스를 실행하는 방식을 취함<br><br>

<b>Kubernetes Orchestration</b>

1. 자동화된 롤아웃 & 롤백: 애플리케이션의 새 버전을 점진적으로 배포하고 문제가 발생했을 때 이전 버전으로 롤백하는 과정을 자동화.

2. 로드 밸런싱: Kubernetes는 트래픽이 많을 때 자동으로 트래픽을 분산시켜 서비스의 안정성을 유지.

3. 자동화된 스케일링: 시스템 부하에 따라 컨테이너 인스턴스의 수를 자동으로 늘리거나 줄여, 자원을 효율적으로 사용하도록 관리.

4. 자동화된 힐링: 컨테이너가 실패하거나 응답하지 않을 경우, 문제의 컨테이너를 자동으로 재시작하거나 교체하여 애플리케이션의 가용성을 보장.

</details>

<hr>

## ⚙️ Prometheus / Grafana

<div align="center">

|Prometheus|Grafana|
|:---:|:---:|
|<img src="https://github.com/mini-xi/ittyreadme/blob/a6bd6a757e8aa88db9c62752b6ceccd5519cacff/img/prometheus.png"/>|<img src="https://github.com/mini-xi/ittyreadme/blob/a6bd6a757e8aa88db9c62752b6ceccd5519cacff/img/grafana.png"/>|
|오픈 소스 모니터링 및 알림 도구. 시스템과 서비스의 성능을 실시간으로 감시하며, 주로 시간에 따른 데이터 포인트들을 수집하는 시계열 데이터베이스 형태로 작동. 다양한 설정 가능한 알림 규칙을 통해 문제가 발생했을 때 경고를 보낼 수 있음|다양한 데이터 소스를 연동하여 시각적으로 데이터를 보여주는 대시보드 및 그래픽 도구. Prometheus, InfluxDB 등과 같은 여러 모니터링 도구의 데이터를 통합하여 사용자가 시각적으로 이해하기 쉬운 그래프, 차트 등을 생성.|
</div>

<b> 프로메테우스는 실시간으로 서비스의 핵심 지표를 수집 및 저장, Grafana는 이 데이터를 시각적 대시보드로 변환해 관리자가 서비스 상태를 쉽게 모니터링. 시스템의 CPU, 메모리, 네트워크 사용량 등을 지속적으로 추적하며, 문제 발생 시 Slack을 통해 즉각적인 알림을 ITTY 관리자에게 제공.</b>

### 🔴 Error 발생 시
<details>
<summary><b>Error 발생(ex: 과부하) 시에는 Slack으로 알림</b></summary>
<div align="center">
	<img src="https://github.com/mini-xi/ittyreadme/blob/57d18277934536ec1be73660e8aa900c4cbcb4b9/img/%EC%83%81%ED%83%9C%EC%A1%B0%ED%9A%8C.png"/><br>
	→ Grafana로 상태 조회<br><br>
	<img src="https://github.com/mini-xi/ittyreadme/blob/57d18277934536ec1be73660e8aa900c4cbcb4b9/img/L_jenkinsR_server.png"/><br>
	→ Left(왼쪽)는 Jenkins, Right(오른쪽)는 Server를 나타냄<br><br>
	<img src="https://github.com/mini-xi/ittyreadme/blob/57d18277934536ec1be73660e8aa900c4cbcb4b9/img/testAlert.png"/><br>
        → Slack으로 오는 Test Alert. 추후에 오류에 대한 메세지(알림) 내용 추가 가능

</div>

</details>

## 회고

|&nbsp;&nbsp;팀&nbsp;원&nbsp;&nbsp;&nbsp;|회고록|
|:---:|---|
|배성민|&nbsp;이번 프로젝트는 데브옵스에 관한 내용이 담겨 있는 프로젝트였고, 백엔드와 프론트엔드를 구축을 해서 도커 컨테이너를 쿠버네티스로 관리하는 프로젝트를 진행했습니다.<br>&nbsp;제가 맡았던 역할은 프론트엔드 부분을 Bootstrap, HTML을 사용해서 먼저 화면을 구성하고, 이를 Vue파일로 옮기는 진행했는데 초반에는 CSS가 전역으로 설정이 되기도 하고, 원하는 기능이 제대로 적용되지 않는 구분도 많았습니다. 이는 CSS를 나누거나, 화면 구성만 해두고 백을 연동하는 과정에서 axios를 이용해서 기능을 추가해나가며 해결할 수 있었습니다.<br>&nbsp;모델링 및 화면 설계 과정에서 팀원들끼리 충분한 상의가 되어서 어느 위치에 어떤 기능이 위치해야하는지 논의를 거쳤음에도 불구하고, 프론트 과정 중에 추가하는 내용이나, 백엔드 설계 중에 화면에 추가 되어야 할 내용이 수정이 있었지만 매일 회의를 하고, Jira, Slack, Figma, Miro, GitHub 등 협업 툴을 사용하는 것으로 크게 힘든 부분 없이 프로젝트를 진행할 수 있었습니다. 프론트엔드와 백엔드 연동에서는 크게 문제가 없었지만, 배포 및 빌드 과정에서 같은 서버와 데이터베이스를 사용하며 조금 어려움이 있었습니다. 특히 MAC과 Window의 차이, 빌드 과정에서 Docker Hub에 관한 문제점들이 있었는데, 이런 부분들을 함께 해결해나가며 잘 이해할 수 있었습니다.<br>&nbsp;단순히 프론트, 백, 인프라라는 각자의 역할에서 그치는 것이 아니라 진행상황을 공유하고 서로에게 설명하는 것으로 전체적인 프로젝트를 이해하며 할 수 있었던 것 같습니다.|
|소우주|&nbsp;프로젝트에서 백엔드 개발을 맡아 진행하였습니다. 어떻게 하면 프론트엔드 단에서 더 쉽게 백엔드 데이터를 가져가 처리할 수 있을지에 대한 고민을 가지며 API와 메소드 그리고 ResponseEntity를 구축했습니다.<br>&nbsp;그러나 처음부터 완벽할 수는 없듯이 크고 작은 수정사항들이 생겼고 그것을 매번 수정하여 팀원들에게 배포할 때마다 많은 번거로움이 있었습니다. 이 시점에 도입된 CI/CD 개념이 이러한 번거로움을 해소하여 협업을 원활히 하는 데에 있어 정말 중요한 역할을 하고 있음을 절실히 알게 되었습니다.<br>&nbsp;또한, 설정파일(application.yml) 내부의 토큰, 키 값 등 민감 정보들을 그대로 배포하는 것은 프로그램 내/외부적으로 치명적 문제가 생길 수 있기에 Jasypt를 도입하여 설정파일의 민감 정보들을 암호화하여 배포하였습니다. Jasypt 도입과 함께 프로젝트의 보안 측면에 관해서도 공부를 하게 되었는데, 보안 관련해서도 항상 긴장을 늦추지 말아야 함을 알게 되었습니다.|
|손세림|&nbsp;이번 프로젝트를 시작하기 앞서 프로젝트를 하는데 필요한 팀 내 규칙을 규정하였습니다.<br>&nbsp;팀원들과 함께 상의하며 DB, Java, Vue 컨벤션 룰을 작성하고, 소스 코드를 관리하는 Git Commit Convention 또한 철저히 설정하였으며,이로 인해 다른사람이 작업한 내용을 확인하거나 프로젝트 진척도를 확인하는데 큰 도움이 되었습니다.&nbsp;여러 사람들이 함께 작업하는 만큼 잘 정해진 룰의 중요성에 대해 다시금 깨닫게 되었습니다.<br>&nbsp;지난 번에 이어 이번 프로젝트에서도 로그인 파트를 맡게되어, 이전에 구현하지 못했던 Acess Token과 Refresh Token 발급과 Redis를 활용한 로그아웃 기능을 구현하였습니다. 로그아웃된 토큰을 처리하는 부분에서 생각보다 많은 시간이 소요되어 기간 내 구현하지 못한 부분이 많아 아쉽기도 하지만, 이 후에도 프로젝트를 고도화해 나가며 미흡한 로그아웃과 탈퇴 처리 기능을 보완하고, OAuth 인증 방식을 도입할 예정입니다. 또한 로그인 파트 뿐만이 아닌 다른 기능 구현에도 적극적으로 참여하여 다양한 경험을 하고 싶습니다.<br>&nbsp;마지막으로, 매일 학원 마감 시간까지 남아 함께 작업하며 고생한 팀원들에게 감사 인사를 전하고 싶습니다.|
|신대영|&nbsp;프로젝트를 진행하며 인프라 시스템 구축을 맡게 되었습니다. 효율성과 안정성을 고려하여 시스템을 구상하며, 쿠버네티스를 활용하기로 결정했습니다. 장애 대응 및 자동화를 위해 MariaDB, Backend, Frontend, Redis를 쿠버네티스 환경으로 이관했습니다. 또한, CI/CD 프로세스를 자동화하기 위해 Jenkins를 도입했는데, 트래픽 증가로 인한 성능 저하를 방지하기 위해 Jenkins를 담당하는 별도의 서버를 구축하고 Docker 컨테이너를 사용했습니다. 그리고 이 두 서버의 자원 사용량과 트래픽 등을 모니터링하기 위해 Prometheus와 Grafana를 도입했습니다.<br>&nbsp;현재는 Backend와 Jenkins만 모니터링이 가능하지만, 추후에는 쿠버네티스의 pods 정보를 수집하여 모니터링하는 환경을 구축할 계획입니다. 또한 argro cd를 통해 docker image 변경 시 k8s 재시작과 같은 자동화도 적용해볼 계획입니다.<br>&nbsp;인프라 구축에 있어서는 효율성과 안정성이 매우 중요하다는 것을 깨달았습니다. 쿠버네티스와 같은 오케스트레이션 도구를 활용하면 시스템의 관리와 운영이 훨씬 효율적으로 이루어질 수 있음을 알았습니다. 또한, 모니터링은 시스템의 안정성을 유지하기 위해 꼭 필요한 요소라는 것을 깨달았습니다. Prometheus와 Grafana를 통해 시스템의 상태를 실시간으로 모니터링하고 대응하는 것이 중요함을 깨달았습니다.|
|이준형|&nbsp;이번 단위 프로젝트는 개발자들을 대상으로 사용자에게 최신 IT 정보와 기술을 제공하고 사용자들 간 정보를 주고받을 수 있는 커뮤니티 서비스 개발을 진행하였다.<br>&nbsp;짧은 기간 동안 프로젝트의 빠른 진행을 위해 프론트와 백엔드 그리고 데브옵스 작업을 분업하였고, 그중 프론트를 담당하며 Vue를 사용하여 화면을 구성하였다.<br>&nbsp;화면을 구성하며 Vue를 복습해 볼 수 있어 좋았고 직접 작업해 보지 못한 데브옵스 관련 작업들은 프로젝트에 설정되어 있는 내용을 보며 복습해 봐야겠다.|
